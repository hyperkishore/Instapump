#!/bin/bash
# Sync userscript to Safari extension and rebuild
# Run this after updating instapump.user.js

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(dirname "$SCRIPT_DIR")"
USERSCRIPT="$REPO_ROOT/userscript/instapump.user.js"
EXTENSION_DIR="$SCRIPT_DIR/instapump-appstore"
XCODE_DIR="$SCRIPT_DIR/InstaPump-Xcode/InstaPump"

echo "ðŸ“¦ InstaPump Safari Extension - Sync & Build"
echo "============================================="

# Check userscript exists
if [ ! -f "$USERSCRIPT" ]; then
    echo "âŒ Userscript not found: $USERSCRIPT"
    exit 1
fi

# Extract version from userscript
VERSION=$(grep -m1 "const VERSION = " "$USERSCRIPT" | sed "s/.*'\([^']*\)'.*/\1/")
echo "ðŸ“‹ Userscript version: $VERSION"

# Create content.js with Safari header
echo "ðŸ”„ Syncing userscript to content.js..."

# Generate Safari header
cat > "$EXTENSION_DIR/content.js" << HEADER
/**
 * InstaPump - Safari Web Extension Content Script
 * Clean Instagram Reels experience with account filtering
 *
 * Version: $VERSION (Safari Extension)
 * Synced from InstaPump userscript v$VERSION
 * Auto-generated by sync-and-build.sh - DO NOT EDIT DIRECTLY
 */

HEADER

# Append userscript without the UserScript header (skip lines starting with //)
sed -n '/^(function()/,$ p' "$USERSCRIPT" >> "$EXTENSION_DIR/content.js"

# Add Safari message listener before the closing })();
# First, remove the closing })();
sed -i '' '$ d' "$EXTENSION_DIR/content.js"

# Add message listener
cat >> "$EXTENSION_DIR/content.js" << 'LISTENER'

  // ========================================
  // Safari Extension Message Listener
  // ========================================
  if (typeof browser !== 'undefined' && browser.runtime && browser.runtime.onMessage) {
    browser.runtime.onMessage.addListener((message, sender, sendResponse) => {
      console.log('[InstaPump] Received message:', message.type);

      if (message.type === 'GET_STATE') {
        const state = {
          mode: currentMode,
          allowlist: getAllowlist(),
          blocklist: getBlocklist(),
          stats: {
            sessionSkipped: sessionStats.reelsSkipped,
            sessionViewed: sessionStats.reelsViewed,
            timeSaved: Math.round((sessionStats.reelsSkipped * 20) / 60),
            watchTimeMs: sessionStats.watchTimeMs
          },
          version: VERSION
        };
        sendResponse(state);
      }
      else if (message.type === 'SET_MODE') {
        currentMode = message.mode;
        localStorage.setItem(STORAGE_KEY_MODE, message.mode);
        updateModeUI();
        showToast(message.mode === 'discovery' ? 'Discovery Mode' : 'Whitelist Mode');
        sendResponse({ success: true });
      }
      else if (message.type === 'IMPORT_ALLOWLIST') {
        const allowlist = getAllowlist();
        let added = 0;
        message.usernames.forEach(u => {
          const username = u.toLowerCase().trim();
          if (username && !allowlist.includes(username)) {
            allowlist.push(username);
            added++;
          }
        });
        saveAllowlist(allowlist);
        updateListCount();
        sendResponse({ added, total: allowlist.length });
      }
      else if (message.type === 'CLEAR_LISTS') {
        localStorage.removeItem(STORAGE_KEY_ALLOWLIST);
        localStorage.removeItem(STORAGE_KEY_BLOCKLIST);
        updateListCount();
        showToast('Lists cleared');
        sendResponse({ success: true });
      }
      else if (message.type === 'REMOVE_FROM_LIST') {
        if (message.listType === 'allowlist') {
          const list = getAllowlist();
          const idx = list.indexOf(message.username);
          if (idx > -1) {
            list.splice(idx, 1);
            saveAllowlist(list);
          }
        } else {
          const list = getBlocklist();
          const idx = list.indexOf(message.username);
          if (idx > -1) {
            list.splice(idx, 1);
            saveBlocklist(list);
          }
        }
        updateListCount();
        sendResponse({ success: true });
      }

      return true;
    });

    console.log('[InstaPump] Safari extension message listener registered');
  }
})();
LISTENER

echo "âœ… content.js updated"

# Copy to Xcode project
if [ -d "$XCODE_DIR" ]; then
    cp "$EXTENSION_DIR/content.js" "$XCODE_DIR/Shared (Extension)/Resources/content.js"
    echo "âœ… Copied to Xcode project"
fi

# Update manifest version
sed -i '' "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" "$EXTENSION_DIR/manifest.json"
echo "âœ… manifest.json version updated to $VERSION"

echo ""
echo "ðŸŽ‰ Sync complete!"
echo ""
echo "Next steps:"
echo "  1. Open Xcode: open '$XCODE_DIR/InstaPump.xcodeproj'"
echo "  2. Build: Cmd+B"
echo "  3. Test in Safari"
echo "  4. Archive for App Store: Product â†’ Archive"
